# -*- coding: utf-8 -*-
"""
코딩테스트 Python 핵심 정리 노트
"""

from collections import Counter, defaultdict, deque
import bisect
import math
from itertools import combinations, permutations, product, combinations_with_replacement

# ============================================================================
# 1. 수학 연산
# ============================================================================

# 최대공약수, 최소공배수
math.gcd(10, 5)  # Greatest Common Divisor. 최대공약수, 5
math.lcm(10, 5)  # Least Common Multiple. 최소공배수, 10

# 제곱, 제곱근
2**10  # 1024
math.sqrt(16)  # 제곱근. 4.0
math.pow(2, 3)  # 제곱. 8.0

# 올림, 내림, 반올림
math.ceil(3.2)  # 올림. 4
math.floor(3.8)  # 내림. 3
round(3.5)  # 반올림. 4
round(3.14159, 2)  # 3.14 (소수점 2자리)

# 진법 변환
bin(10)  # "0b1010"
oct(10)  # "0o12"
hex(10)  # "0xa"
int("0b1010", 2)  # 10 (2진수 → 10진수)
int("1010", 2)  # 10

# ============================================================================
# 2. 문자열 처리
# ============================================================================

s = "hello"

# 문자열 뒤집기
s[::-1]  # "olleh"
reversed(s)  # <reversed object> (iterator 타입, 리스트가 아님!)
list(reversed(s))  # ['o', 'l', 'l', 'e', 'h'] (리스트로 변환)
"".join(reversed(s))  # "olleh" (문자열로 변환)

# 문자열 체크
s.isalpha()  # 알파벳만 있나?
s.isdigit()  # 숫자만 있나? (유니코드 숫자 포함: ², ³ 등도 True)
s.isdecimal()  # 10진수 숫자만 있나? (0-9만 True, ², ³ 등은 False)
# 차이점: isdigit()은 ², ³ 같은 유니코드 숫자도 True, isdecimal()은 0-9만 True
"²".isdigit()  # True
"²".isdecimal()  # False
"123".isdigit()  # True
"123".isdecimal()  # True
s.isalnum()  # 알파벳+숫자만 있나?

# 아스키 변환
ord("A")  # 65
chr(65)  # "A"

# 대소문자 변환
s.upper()  # 대문자로
s.lower()  # 소문자로
s.swapcase()  # 대소문자 변경
s.capitalize()  # 첫 글자만 대문자
s.title()  # 단어별 첫 글자 대문자

# 문자열 찾기/변환
s.find("ll")  # 2 (첫 위치, 없으면 -1)
s.index("ll")  # 2 (첫 위치, 없으면 에러)
s.count("l")  # 2 (개수)
s.replace("l", "L")  # "heLLo"
s.split()  # 공백으로 분리
",".join(["a", "b", "c"])  # "a,b,c"

# ============================================================================
# 3. 리스트/배열 조작
# ============================================================================

# 배열 초기화
n, m = 5, 3
arr1 = [0] * n  # [0, 0, 0, 0, 0]

# 2차원 배열 초기화 (올바른 방법)
arr2d = [[0] * m for _ in range(n)]  # 각각 독립적인 리스트 생성
# ❌ 잘못된 방법: arr2d = [[0] * m] * n
# 차이점: [[0]*m]*n은 같은 리스트 객체를 n번 참조하므로, 하나 수정하면 모두 수정됨
wrong = [[0] * 3] * 2  # [[0, 0, 0], [0, 0, 0]] (같은 객체 참조)
wrong[0][0] = 1  # [[1, 0, 0], [1, 0, 0]] (둘 다 변경됨!)
correct = [[0] * 3 for _ in range(2)]  # [[0, 0, 0], [0, 0, 0]] (독립적)
correct[0][0] = 1  # [[1, 0, 0], [0, 0, 0]] (하나만 변경됨)

# 리스트 회전
arr = [1, 2, 3, 4]
arr[1:] + arr[:1]  # [2, 3, 4, 1] (왼쪽 회전)
arr[-1:] + arr[:-1]  # [4, 1, 2, 3] (오른쪽 회전)

# 리스트 뒤집기
arr[::-1]  # 새 리스트 반환
arr.reverse()  # 원본 수정

# 중복 제거
arr = [1, 2, 2, 3, 1, 4]

# 방법 1: set 사용 (가장 간단, 순서 보장 안됨 - Python 3.7 이전)
list(set(arr))  # [1, 2, 3, 4] 또는 [2, 1, 3, 4] (순서 무작위, Python 3.6 이하)
# Python 3.7+에서는 set도 삽입 순서 유지

# 방법 2: dict.fromkeys 사용 (순서 유지, 추천!)
list(dict.fromkeys(arr))  # [1, 2, 3, 4] (순서 유지, Python 3.7+)

# 방법 3: set + 리스트 컴프리헌션 (순서 유지, 복잡함)
seen = set()
[x for x in arr if x not in seen and not seen.add(x)]
# 참고: seen.add(x)는 None을 반환하므로 not seen.add(x)는 항상 True
# 하지만 x not in seen이 False면 뒤를 확인하지 않으므로 add가 실행되지 않음

# 리스트 분할
arr = [1, 2, 3, 4, 5]
arr[:3], arr[3:]  # ([1, 2, 3], [4, 5])

# 리스트 연산
[1, 2] + [3, 4]  # [1, 2, 3, 4] (연결)
[1, 2] * 3  # [1, 2, 1, 2, 1, 2] (반복)
[0] * 5  # [0, 0, 0, 0, 0]

# ============================================================================
# 4. 딕셔너리 (dict)
# ============================================================================

d = {"a": 1, "b": 2, "c": 3}

# 딕셔너리 조작
d["d"] = 4  # 추가
d.get("e", 0)  # 0 (키 없으면 기본값)
d.keys()  # dict_keys(['a', 'b', 'c', 'd'])
d.values()  # dict_values([1, 2, 3, 4])
d.items()  # dict_items([('a', 1), ('b', 2), ...])
d.pop("a")  # 1 반환, {"b": 2, "c": 3, "d": 4}

# 딕셔너리 정렬
sorted(d.items(), key=lambda x: x[1])  # 값으로 오름차순 정렬
sorted(d.items(), key=lambda x: x[1], reverse=True)  # 값으로 내림차순 정렬
sorted(d.items(), key=lambda x: -x[1])  # 값으로 내림차순 정렬 (음수 활용)

# 딕셔너리 병합 (Python 3.9+)
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "b": 99}
d1 | d2  # {"a": 1, "b": 99, "c": 3} (같은 키는 덮어씀)
# 모든 버전: {**d1, **d2} 또는 dict(d1, **d2)

# Counter (카운팅)
counter = Counter([1, 2, 2, 3, 3, 3])
counter.most_common(2)  # [(3, 3), (2, 2)] (가장 많이 나온 2개)
counter[1]  # 1
counter[4]  # 0 (없어도 에러 안남)

# defaultdict (기본값 딕셔너리)
groups = defaultdict(list)
data = [("A", 1), ("B", 2), ("A", 3), ("C", 4), ("B", 5)]  # (key, value) 형태
for key, value in data:  # key와 value를 언패킹
    groups[key].append(value)  # key별로 value들을 그룹핑
# 결과: {"A": [1, 3], "B": [2, 5], "C": [4]}

# 또는 다른 예시
data = [1, 2, 3, 4, 5]
groups = defaultdict(list)
for item in data:
    key = item % 2  # 홀수/짝수로 그룹핑
    groups[key].append(item)
# 결과: {0: [2, 4], 1: [1, 3, 5]}

# ============================================================================
# 5. 큐/스택/덱
# ============================================================================

# 큐 (FIFO - First In First Out)
q = deque()
q.append(1)  # 뒤에 추가
q.append(2)
q.popleft()  # 앞에서 제거 (1 반환)

# 스택 (LIFO - Last In First Out)
stack = []
stack.append(1)  # 추가
stack.append(2)
stack.pop()  # 제거 (2 반환, 마지막 요소)

# 덱 (양방향 큐)
dq = deque([1, 2, 3])
dq.appendleft(0)  # 앞에 추가 → [0, 1, 2, 3]
dq.popleft()  # 앞에서 제거 → [1, 2, 3]
dq.append(4)  # 뒤에 추가 → [1, 2, 3, 4]
dq.pop()  # 뒤에서 제거 → [1, 2, 3]

# ============================================================================
# 6. 정렬
# ============================================================================

arr = [3, 1, 4, 1, 5]

# 기본 정렬
arr.sort()  # 원본 수정 → [1, 1, 3, 4, 5]
sorted_arr = sorted(arr)  # 새 리스트 반환

# 다중 조건 정렬 (2차원 리스트)
arr2d = [[3, 2], [1, 4], [1, 2], [3, 1]]
arr2d.sort(key=lambda x: (x[0], -x[1]))  # 첫 번째 오름차순, 두 번째 내림차순
# 결과: [[1, 4], [1, 2], [3, 2], [3, 1]]
# 첫 번째 원소(x[0])로 먼저 정렬, 같으면 두 번째 원소(-x[1])로 정렬
# -x[1]은 음수로 만들어서 내림차순 효과 (큰 값이 앞으로)

# 커스텀 정렬
arr_str = ["apple", "pie", "banana"]
arr_str.sort(key=lambda x: len(x))  # 길이 기준 → ["pie", "apple", "banana"]

# ============================================================================
# 7. 조합/순열
# ============================================================================

# 조합 (순서 무관, 중복 없음)
list(combinations([1, 2, 3], 2))  # [(1, 2), (1, 3), (2, 3)]

# 순열 (순서 있음)
list(permutations([1, 2, 3], 2))  # [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

# 중복 조합
list(
    combinations_with_replacement([1, 2, 3], 2)
)  # [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

# 곱집합 (카르테시안 곱)
list(product([1, 2], [3, 4]))  # [(1, 3), (1, 4), (2, 3), (2, 4)]

# ============================================================================
# 8. 이진 탐색 (bisect)
# ============================================================================

arr = [1, 3, 5, 7, 9]

# 삽입 위치 찾기
bisect.bisect_left(arr, 5)  # 2 (5가 들어갈 왼쪽 위치)
bisect.bisect_right(arr, 5)  # 3 (5가 들어갈 오른쪽 위치)
bisect.bisect_left(arr, 6)  # 3 (6이 들어갈 위치)

# 삽입
bisect.insort_left(arr, 4)  # [1, 3, 4, 5, 7, 9] (정렬 유지하며 삽입)
bisect.insort_right(arr, 6)  # [1, 3, 4, 5, 6, 7, 9]

# ============================================================================
# 9. 유용한 내장 함수
# ============================================================================

# 최대/최소
max([1, 2, 3])  # 3
min([1, 2, 3])  # 1
max("abc", "def", key=len)  # "abc" (길이 기준)

# 합/곱
sum([1, 2, 3])  # 6
from functools import reduce

reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 24 (곱셈)

# any, all
any([False, True, False])  # True (하나라도 True면 True)
all([True, True, False])  # False (모두 True여야 True)

# divmod (몫과 나머지)
divmod(10, 3)  # (3, 1)

# pow (거듭제곱)
pow(2, 10)  # 1024
pow(2, 10, 1000)  # 24 (1024 % 1000, 모듈로 연산)

# enumerate, zip
list(enumerate(["a", "b", "c"]))  # [(0, 'a'), (1, 'b'), (2, 'c')]
list(zip([1, 2], [3, 4]))  # [(1, 3), (2, 4)]

# filter, map
list(filter(lambda x: x > 2, [1, 2, 3, 4]))  # [3, 4]
list(map(lambda x: x * 2, [1, 2, 3]))  # [2, 4, 6]

# ============================================================================
# 10. 리스트 슬라이싱
# ============================================================================

arr = [0, 1, 2, 3, 4, 5]
arr[1:4]  # [1, 2, 3]
arr[:3]  # [0, 1, 2]
arr[3:]  # [3, 4, 5]
arr[::2]  # [0, 2, 4] (2칸씩)
arr[::-1]  # [5, 4, 3, 2, 1, 0] (역순)
arr[1:4:2]  # [1, 3] (1부터 4까지 2칸씩)

# ============================================================================
# 11. 리스트 컴프리헌션 고급
# ============================================================================

# 조건부
[x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]

# 조건부 값 변경
[x if x > 0 else 0 for x in [-1, 2, -3, 4]]  # [0, 2, 0, 4]

# 중첩
[[i * j for j in range(3)] for i in range(3)]  # 2차원 배열 생성

# ============================================================================
# 12. 문자열/리스트 패턴 매칭
# ============================================================================

s = "hello world"
s.find("ll")  # 2 (첫 위치, 없으면 -1)
s.index("ll")  # 2 (첫 위치, 없으면 에러)
s.count("l")  # 3 (개수)
s.startswith("he")  # True
s.endswith("ld")  # True

arr = [1, 2, 3, 4, 5]
arr.index(3)  # 2 (첫 위치)
3 in arr  # True (존재 여부)

# ============================================================================
# 13. 시간 복잡도 최적화 팁
# ============================================================================

# set/dict는 O(1) 조회
s = set([1, 2, 3])
if 2 in s:  # O(1) - 빠름
    pass

# 리스트는 O(n) 조회
arr = [1, 2, 3]
if 2 in arr:  # O(n) - 느림!
    pass

# 문자열 연결 (join 사용)
# 느림: result += s  (반복문에서)
# 빠름: "".join([s1, s2, s3])
